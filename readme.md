Η mvote έχει σχεδιαστεί να καλύπτει τις απαιτήσεις της εκφώνησης πλήρως. Η εφαρμογή καλείται με δυο flags, -f για το αρχείο από το οποίο θα εισάγουμε τους voters και -b για το μέγεθος κάθε bucket. Χρησιμοποιήθηκαν κυρίως 2 voters ανά bucket. Σε περίπτωση που υπάρχουν παραπάνω flags, το πρόγραμμα εκτυπώνει την σωστή μορφή για τον χρήστη και τερματίζει. Εφόσον δοθεί η κατάλληλη μορφή, τα στοιχεία αποθηκεύονται στο filename και στην global μεταβλητή bucketentries. Έπειτα καλούμε την  mvote κλάση με όνομα election, κατόπιν την συνάρτηση read_file και τα αρχεία θα εισαχθούν στο linear hashtable. Ανάλογα με την κατάλληλη εντολή που θα δοθεί, εκτελείται κι η κατάλληλη συνάρτηση από την κλάση mvote. Το interface είναι:
•	l <PIN>
•	i <PIN> <lname> <fname> <ZIP>
•	m <PIN>
•	v 
•	bv <filename>
•	perc
•	 z <ZIP>
•	 o
•	pr
Η μόνη επιπρόσθετη εντολή είναι η pr, η οποία εκτυπώνει το linear hashtable. Όλες οι άλλες ακολουθούν ακριβώς το format της εκφώνησης.
Είναι σημαντικό να τονιστούν κάποιες λεπτομέρειες: Το πρόγραμμα είναι γραμμένο σε c++ οπότε χρησιμοποιήθηκαν pointers σε char* όπου θα έπρεπε να μπει string. Αναγκαστικά κάνουμε allocate κατάλληλο μήκος array για το char. 

Η κλάση Voter (Voter.h) περιέχει τα συστατικά στοιχεία ενός χρήστης (lname,fname,PIN,ZIP,vote). Με τον constructor του και το new γίνεται allocate ο χρήστης με τα κατάλληλα ορίσματα. Ο destructor ελευθερώνει τα arrays του lname και fname ενώ η print εκτυπώνει τα στοιχεία του Voter.
Η κλάση Node (Node.h) περιέχει τα nodes που χρησιμοποιούνται για την δημιουργία του bucket, το οποίο εκφράζεται ως ένα linked list. Έχει έναν pointer σε voter για τον κάθε voter και pointer next για το επόμενο node στην σειρά.
Η κλάση bucket (Bucket.h) περιέχει δυο node pointers, head και tail που δηλώνουν την κεφαλή και την ουρά της linked list. Επίσης περιέχει την NumOfKeys που κρατάει πόσα keys υπάρχουν σε κάθε buckets καθώς και την overflowed για το πόσα overflowed keys υπάρχουν. Εδώ είναι σημαντικό να τονιστεί η αρχιτεκτονική που σχεδίασα. Ενώ θα μπορούσα να φτιάξω σε κάθε bucket ένα array από επιμέρους buckets όπου το καθένα έχει δυο nodes αποφάσισα να φτιάξω ένα linked list το οποίο δεν έχει περιορισμούς σε keys και άρα τα buckets ανά b (στην περίπτωση μας 2) είναι νοητά και δεν υπάρχουν όντως. Εκφράζονται ωστόσο με τα overflowed keys και επίσης φαίνονται ξεκάθαρα τα overflowed buckets όταν καλεί ο χρήστης την pr. Η όλη σχεδίαση μοιάζει πιο απλή και προσφέρει μικρή πολυπλοκότητα καθώς υπάρχει και ο tail pointer ο οποίος αυξάνεται κάθε φορά που εισέρχεται καινούριο key είτε μέσω της insert είτε μέσω split.

Στην κλάση hashtable υλοποιείται όλη η λογική πίσω από το linear hash table. Περιέχεται το round, η loadfactor, το αρχικό πλήθος buckets και το τρέχων πλήθος, ένας pointer σε bucket p που χρησιμοποιείται κατά το split καθώς και ένας διπλός pointer σε bucket για την δημιουργία του array στο οποίο περιέχονται pointers για κάθε bucket στο hashtable. Κατά την δημιουργία ενός hashtable, o constructor κάνει allocate την κατάλληλη μνήμη χρησιμοποιώντας malloc και αρχικοποιεί και τα επιμέρους buckets χρησιμοποιώντας new. Γενικά, έχουν χρησιμοποιηθεί τόσο εντολές new και delete όσο και malloc, realloc και free. Αυτή η απόφαση πάρθηκε καθώς δεν υπήρχε ανάλογη εντολή realloc για την new και ήθελα να κάνω realloc αντί να δημιουργώ καινούριο hashtable καθώς ήταν πιο αργό και αύξανε την πολυπλοκότητα. Επέμενα στην χρήση new ωστόσο γιατί χρησιμοποιώ τον constructor και τον destructor σε κάθε κλάση. Το hash function παίρνει ως όρισμα το pin, το round που βρισκόμαστε και το μέγεθος κάθε bucket. Η findpindex επιστρέφει το index στο array στο οποίο δείχνει ο pointer p. Η printable καλείται από την pr της mvote για να εκτυπωθεί το hashtable. Στο getloadfactor υπολογίζουμε και επιστρέφουμε το load factor με τον τύπο που δίνεται στο βοηθητικό φυλλάδιο από την εκφώνηση. Στην search ψάχνουμε σύμφωνα με το hash γρήγορα και αποδοτικά ένα pin, καλείται από την αντίστοιχη συνάρτηση στο mvote. Η insert και η split υπήρξαν τα πιο ενδιαφέροντα σημεία της εργασίας θεωρώ. Εάν το hash είναι μικρότερο από το index του p, αυξάνουμε ένα round την hash function. Στην insert αρχικά ψάχνουμε εάν υπάρχει ήδη ο voter με το αντίστοιχο PIN στο table. Εάν δεν υπάρχει, δημιουργούμε ένα node για να αποθηκεύσει τον voter. Εφόσον δεν υπάρχουν keys παραπάνω από το καθόρισμενο numofkeys, το key προστίθεται ως κανονικό key. Διαφορετικά, προστίθεται ως overflowed key. Εάν μετά την επιτυχής εισαγωγή key το loadfactor είναι άνω του 0.75,  καλούμε την split. Στην split αυξάνουμε τα τρέχων buckets και κάνουμε reallocate το array των buckets. Έπειτα δημιουργούμε ένα καινούριο bucket το οποίο θα αντικαταστήσει το bucket του p, καθώς στο συγκεκριμένο τα κλειδιά του θα γίνουν split. Εάν το hash function βρει hash για το PIN του voter το bucket που γίνεται split, η εισαγωγή θα γίνει στο καινούριο bucket το οποίο αντικαθιστούμε στο τέλος. Διαφορετικά, γίνεται η εισαγωγή στο αντίστοιχο bucket του hashtable. Η διαδικασία της εισαγωγής είναι ακριβώς ίδια με αυτής του insert. Στο τέλος κάνουμε delete το παλιό p bucket, αντικαθιστούμε με το καινούριο και αυξάνουμε τον p. Ωστόσο, εάν τα τρέχων buckets πλέον είναι διπλάσια των αρχικών buckets, το round αυξάνεται, τα τρέχων buckets γίνονται αρχικά και το p δείχνει και πάλι στο πρώτο bucket του hashtable.
Η inverted index έχει αντίστοιχη λογική καθώς χρησιμοποιούμε μια linked list με ZIPNodes. Η κλάση ZIPNode περιέχει έναν  pointer head και tail τα οποία χρησιμοποιούνται για την εσωτερική linked list που εμπεριέχει Nodes με voters και αντιστοιχούν στους voters για κάθε ZIP.  Επίσης περιέχει το ZIP, έναν pointer στο επόμενο ZIPNode καθώς και μετρητή για τα PINs που βρίσκονται εκείνη την στιγμή σε κάθε ZIP. Η λογική υλοποιείται κυρίως στην κλάση inverted index, στην οποία υπάρχει ένας pointer για το πρώτο ZIPNode της λίστας, ο αριθμός των συνολικών voters και μετά οι κατάλληλες συναρτήσεις. Στην search ψάχνουμε εάν υπάρχει το αντίστοιχο pin ως voter μέσα στην inverted index, δηλαδή εάν ο voter έχει ψηφίσει. Στην insert προσθέτουμε ένα καινούριο node με voter στο κατάλληλο ZIP εάν υπάρχει, αλλιώς εάν δεν υπάρχει δημιουργούμε και ένα καινούριο ZIPNode για το αντίστοιχο ZIP. Η πολυπλοκότητα εδώ είναι επίσης πολύ μικρή καθώς έχουμε tail pointer στην κλάση zip node και μπορούμε εύκολα να βρούμε το αντίστοιχο zip και να κάνουμε insert τον καινούριο voter. Η Print τέλος, εκτυπώνει για ένα συγκεκριμένο ZIP όλους τους voters. 
Η κλάση mvote είναι εκείνη που τελικά ενώνει τα επιμέρους στοιχεία και δημιουργεί την πλήρης υλοποίηση. Εκεί δημιουργούμε το linear hashtable με όνομα catalog και το inverted index με όνομα ZIPIndex. Εδώ επίσης υλοποιείται η λογική των συναρτήσεων που αντιστοιχούν στις εντολές που δίνει ο χρήστης στο τερματικό. Η l_Search χρησιμοποιεί την search του hashtable για να βρει εάν υπάρχει ο voter με το συγκεκριμένο pin. Με την I προσθέτουμε καινούριο voter με την insert του hashtable. Με την m ο voter πλέον έχει ψηφίσει και χρησιμοποιούμε την insert της ZIPIndex για να τον προσθέσουμε και στο inverted index. H v εκτυπώνει το σύνολο των voters που ψήφισαν. Το perc βρίσκει το ποσοστό αυτών που ψήφισαν συγκρίνοντας το σύνολο των keys στο ZIPIndex προς το σύνολο των keys στο hashtable. H z εκτυπώνει όλους τους voters στο κατάλληλο zip χρησιμοποιώντας τις αντίστοιχες συναρτήσεις της ZIPIndex. H o εκτυπώνει ταξινομημένα τα ZIP από αυτό με τους περισσότερους voters σε αυτόν με τους λιγότερους. Αρχικά εδώ θα χρησιμοποιούσα την qsort αλλά λόγω προβλημάτων με τον comparator έγραψε μια δικιά μου πολύ απλή bubblesort η οποία βέβαια αυξάνει την average πολυπλοκότητα. Η bv καλώντας την m αλλάζει ανάλογα με το αρχείο τα votes των αντίστοιχων voters. Η read file διαβάζει το αντίστοιχο file που δίνεται από το τερματικό και εισάγει τους voters στο hashtable. Τέλος η pr εκτυπώνει το hashtable. 
Εδώ πρέπει να τονίσουμε ότι προκειμένου να αποκομιστούν τα απαραίτητα συστατικά στοιχεία κάθε character array, χρησιμοποιούμε την λογική του strtok όπου χωρίζουμε ουσιαστικά το array μέχρι την εμφάνιση ενός space. 
Για να εκτελεστεί το πρόγραμμα με προκαθορισμένα flags -f voters5000.csv και -b 2 χρησιμοποιείστε το makefile που βρίσκεται μέσα στον φάκελο.
Τρέξετε main για να δημιουργηθεί το εκτελέσιμο, make run για να τρέξει το εκτελέσιμο και make clean για να διαγραφτεί. 
Ευχαριστώ προκαταβολικά και καλή συνέχεια.
